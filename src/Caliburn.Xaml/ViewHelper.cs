using System;
using System.Reflection;
#if NETFX_CORE
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Markup;
using Windows.UI.Xaml.Media;
#else
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Markup;
using System.Windows.Media;
#endif

namespace Caliburn.Light
{
    /// <summary>
    /// Some helper methods when dealing with UI elements.
    /// </summary>
    public static class ViewHelper
    {
        private static readonly DependencyProperty PreviouslyAttachedProperty =
            DependencyProperty.RegisterAttached("PreviouslyAttached", typeof (bool), typeof (ViewHelper), null);

        private static readonly DependencyProperty IsGeneratedProperty =
            DependencyProperty.RegisterAttached("IsGenerated", typeof (bool), typeof (ViewHelper), null);

        /// <summary>
        /// Used to retrieve the root, non-framework-created view.
        /// </summary>
        /// <param name="view">The view to search.</param>
        /// <returns>The root element that was not created by the framework.</returns>
        /// <remarks>In certain instances the services create UI elements.
        /// For example, if you ask the window manager to show a UserControl as a dialog, it creates a window to host the UserControl in.
        /// The WindowManager marks that element as a framework-created element so that it can determine what it created vs. what was intended by the developer.
        /// Calling GetFirstNonGeneratedView allows the framework to discover what the original element was. 
        /// </remarks>
        public static object GetFirstNonGeneratedView(DependencyObject view)
        {
            if (!(bool) view.GetValue(IsGeneratedProperty)) return view;

            var contentControl = view as ContentControl;
            if (contentControl != null)
                return contentControl.Content;

            var contentProperty = FindContentProperty(view);
            return contentProperty.GetValue(view);
        }

        /// <summary>
        /// Sets the IsGenerated property for <paramref name="view"/>.
        /// </summary>
        /// <param name="view">The view.</param>
        /// <param name="value">true, if the view is generated by the framework.</param>
        public static void SetIsGenerated(DependencyObject view, bool value)
        {
            view.SetValue(IsGeneratedProperty, value);
        }

        /// <summary>
        /// Executes the handler the fist time the element is loaded.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="handler">The handler.</param>
        public static void ExecuteOnFirstLoad(FrameworkElement element, RoutedEventHandler handler)
        {
            if ((bool) element.GetValue(PreviouslyAttachedProperty)) return;
            element.SetValue(PreviouslyAttachedProperty, true);
            ExecuteOnLoad(element, handler);
        }

        /// <summary>
        /// Executes the handler immediately if the element is loaded, otherwise wires it to the Loaded event.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="handler">The handler.</param>
        /// <returns>true if the handler was executed immediately; false otherwise</returns>
        public static bool ExecuteOnLoad(FrameworkElement element, RoutedEventHandler handler)
        {
            if (IsElementLoaded(element))
            {
                handler(element, new RoutedEventArgs());
                return true;
            }

            RoutedEventHandler loaded = null;
            loaded = (s, e) =>
            {
                element.Loaded -= loaded;
                handler(s, e);
            };
            element.Loaded += loaded;
            return false;
        }

        /// <summary>
        /// Executes the handler when the element is unloaded.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="handler">The handler.</param>
        public static void ExecuteOnUnload(FrameworkElement element, RoutedEventHandler handler)
        {
            RoutedEventHandler unloaded = null;
            unloaded = (s, e) =>
            {
                element.Unloaded -= unloaded;
                handler(s, e);
            };
            element.Unloaded += unloaded;
        }

        /// <summary>
        /// Executes the handler the next time the elements's LayoutUpdated event fires.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="handler">The handler.</param>
#if NETFX_CORE
        public static void ExecuteOnLayoutUpdated(FrameworkElement element, EventHandler<object> handler) {
            EventHandler<object> onLayoutUpdate = null;
#else
        public static void ExecuteOnLayoutUpdated(FrameworkElement element, EventHandler handler)
        {
            EventHandler onLayoutUpdate = null;
#endif
            onLayoutUpdate = (s, e) =>
            {
                element.LayoutUpdated -= onLayoutUpdate;
                handler(s, e);
            };
            element.LayoutUpdated += onLayoutUpdate;
        }

        /// <summary>
        /// Determines whether the specified <paramref name="element"/> is loaded.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <returns>true if the element is loaded; otherwise, false.
        /// </returns>
        public static bool IsElementLoaded(FrameworkElement element)
        {
            if (element == null)
                return false;

#if NETFX_CORE
            var content = Window.Current.Content;
            var parent = element.Parent ?? VisualTreeHelper.GetParent(element);
            return parent != null || (content != null && element == content);
#elif SILVERLIGHT
            //var root = Application.Current.RootVisual;
            var parent = element.Parent ?? VisualTreeHelper.GetParent(element);
            var children = VisualTreeHelper.GetChildrenCount(element);
            return parent != null && children > 0;
#else
            return element.IsLoaded;
#endif
        }

        private const string DefaultContentPropertyName = "Content";

        /// <summary>
        /// Finds the Content property of specified <paramref name="element"/>.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <returns>An object that represents the specified property, or null if the property is not found.</returns>
        public static PropertyInfo FindContentProperty(object element)
        {
            var type = element.GetType();
            var contentPropertyAttribute = type.GetTypeInfo().GetCustomAttribute<ContentPropertyAttribute>(true);
            var contentPropertyName = (contentPropertyAttribute == null) ? DefaultContentPropertyName : contentPropertyAttribute.Name;
            return type.GetRuntimeProperty(contentPropertyName);
        }

        /// <summary>
        /// Determines whether a particular dependency property already has a binding on the provided element.
        /// </summary>
        public static bool HasBinding(FrameworkElement element, DependencyProperty property)
        {
#if SILVERLIGHT || NETFX_CORE
            return element.GetBindingExpression(property) != null;
#else
            return BindingOperations.GetBindingBase(element, property) != null;
#endif
        }
    }
}
